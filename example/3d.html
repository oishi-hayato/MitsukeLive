3<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>MitsukeLive - 3D/AR Mode Demo</title>
    <link rel="stylesheet" href="style.css" />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/@mdi/font@7.4.47/css/materialdesignicons.min.css"
    />
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
  </head>
  <body>
    <div id="app"></div>

    <script type="module">
      import * as MitsukeLive from "../dist/index.js";
      import { createGlossyCard, setupSceneLighting } from "./card-model.js";

      const { createApp, ref, onMounted, onUnmounted } = Vue;

      // Constants
      const CAMERA_FOV = 50; // Camera field of view in degrees

      const MODEL_PATHS = {
        modelPath: "models/model.json",
        metadataPath: "models/metadata.yaml",
      };

      const DETECTOR_OPTIONS = {
        detection: {
          scoreThreshold: 0.7, // Only detect objects with 70% or higher confidence
          inferenceInterval: 16, // ~60 FPS detection (16ms interval)
        },
        threeDEstimation: {
          objectSize: {
            width: 0.02, // 2cm
            height: 0.02, // 2cm
          },
          cameraFov: CAMERA_FOV,
        },
      };

      const MESSAGES = {
        INITIALIZING: "Initializing...",
        CAMERA_INIT: "Initializing camera...",
        READY: "Please scan an object",
        PAUSED: "Detection paused",
        CAMERA_DENIED: "Camera access denied",
      };

      const DetectionApp = {
        setup() {
          const state = {
            status: ref(MESSAGES.INITIALIZING),
            detectionInfo: ref(null),
            error: ref(""),
            isDetecting: ref(false),
          };

          let detector = null;
          let scene = null;
          let camera = null;
          let renderer = null;
          let cubes = []; // Manage multiple objects
          let animationId = null;
          let dynamicLights = []; // Lights that follow the card

          // Smoothing variables for interpolation
          let targetPosition = { x: 0, y: 0, z: -0.05 };
          let targetRotation = { x: 0, y: 0, z: 0 };
          let currentPosition = { x: 0, y: 0, z: -0.05 };
          let currentRotation = { x: 0, y: 0, z: 0 };
          const lerpFactor = 0.25; // Higher smoothing factor for faster response with higher FPS

          // Card appearance animation variables
          let cardAnimation = {
            isPlaying: false,
            startTime: 0,
            duration: 1500, // 1.5 seconds
            startScale: 0.1,
            startOpacity: 0.0,
            startY: -0.08, // Start below the target position
            targetScale: 1.0,
            targetOpacity: 0.7, // Glass opacity
            targetY: -0.05, // Target position
            hasPlayedOnce: false // Track if animation has been played
          };

          // Initialize Three.js scene
          const initThreeJS = () => {
            const canvas = document.getElementById("ar-canvas");
            const detectionCanvas = document.getElementById("canvas");

            // Create renderer
            renderer = new THREE.WebGLRenderer({
              canvas: canvas,
              alpha: true,
              antialias: true,
            });

            renderer.setSize(detectionCanvas.width, detectionCanvas.height);
            canvas.style.width =
              detectionCanvas.style.width || `${detectionCanvas.width}px`;
            canvas.style.height =
              detectionCanvas.style.height || `${detectionCanvas.height}px`;
            renderer.setPixelRatio(window.devicePixelRatio);

            // Create scene
            scene = new THREE.Scene();

            // Create camera
            camera = new THREE.PerspectiveCamera(
              CAMERA_FOV,
              detectionCanvas.width / detectionCanvas.height,
              0.01, // Near: 1cm
              1000 // Far: 10m for long distance detection
            );
            camera.position.z = 0;

            // Create black glass card model using external module
            const card = createGlossyCard(
              0.02, // 20mm width
              0.028, // 28mm height (20mm * 1.4 ratio)
              0.0005, // 0.5mm thickness
              0.002, // 2mm corner radius
              0.7, // 70% opacity (more visible glass)
              0.9 // 90% gloss level (very glossy glass)
            );
            card.visible = false;
            cubes.push(card);
            scene.add(card);

            // Set up scene lighting
            setupSceneLighting(scene);

            // Add dynamic lights that will follow the card
            const cardFollowLight1 = new THREE.DirectionalLight(0xffffff, 0.8);
            const cardFollowLight2 = new THREE.PointLight(0xffffff, 0.6);
            const cardFollowLight3 = new THREE.PointLight(0xaaccff, 0.3);

            scene.add(cardFollowLight1);
            scene.add(cardFollowLight2);
            scene.add(cardFollowLight3);

            dynamicLights.push(
              cardFollowLight1,
              cardFollowLight2,
              cardFollowLight3
            );
          };

          // Linear interpolation helper function
          const lerp = (start, end, factor) => {
            return start + (end - start) * factor;
          };

          // Three.js animation loop
          const animate = () => {
            animationId = requestAnimationFrame(animate);

            // Handle card appearance animation
            if (cardAnimation.isPlaying && cubes.length > 0) {
              const card = cubes[0];
              const elapsed = Date.now() - cardAnimation.startTime;
              const progress = Math.min(elapsed / cardAnimation.duration, 1.0);

              // Easing function (ease-out)
              const easeOut = 1 - Math.pow(1 - progress, 3);

              // Animate scale
              const currentScale =
                cardAnimation.startScale +
                (cardAnimation.targetScale - cardAnimation.startScale) *
                  easeOut;
              card.scale.set(currentScale, currentScale, currentScale);

              // Animate opacity
              const currentOpacity =
                cardAnimation.startOpacity +
                (cardAnimation.targetOpacity - cardAnimation.startOpacity) *
                  easeOut;
              card.material.opacity = currentOpacity;
              card.material.transparent = true;

              // Animate Y position (bottom to top movement)
              const currentY =
                cardAnimation.startY +
                (cardAnimation.targetY - cardAnimation.startY) * easeOut;
              card.position.z = currentY;

              // Animation complete
              if (progress >= 1.0) {
                cardAnimation.isPlaying = false;
                cardAnimation.hasPlayedOnce = true; // Mark animation as completed
                card.material.transparent = currentOpacity < 1.0;
                // Initialize position for smooth interpolation after animation
                currentPosition.x = card.position.x;
                currentPosition.y = card.position.y;
                currentPosition.z = card.position.z;
              }

              // Update dynamic lights during animation
              updateDynamicLights(card);
            }
            // Smooth interpolation for card position and rotation (only when not animating)
            else if (
              cubes.length > 0 &&
              cubes[0].visible &&
              !cardAnimation.isPlaying
            ) {
              const card = cubes[0];

              // Interpolate position
              currentPosition.x = lerp(
                currentPosition.x,
                targetPosition.x,
                lerpFactor
              );
              currentPosition.y = lerp(
                currentPosition.y,
                targetPosition.y,
                lerpFactor
              );
              currentPosition.z = lerp(
                currentPosition.z,
                targetPosition.z,
                lerpFactor
              );

              // Interpolate rotation
              currentRotation.x = lerp(
                currentRotation.x,
                targetRotation.x,
                lerpFactor
              );
              currentRotation.y = lerp(
                currentRotation.y,
                targetRotation.y,
                lerpFactor
              );
              currentRotation.z = lerp(
                currentRotation.z,
                targetRotation.z,
                lerpFactor
              );

              // Apply smoothed values to card
              card.position.set(
                currentPosition.x,
                currentPosition.y,
                currentPosition.z
              );
              card.rotation.set(
                currentRotation.x,
                currentRotation.y,
                currentRotation.z
              );

              // Update dynamic lights with smoothed position and rotation
              updateDynamicLights(card);
            }

            // Just render the scene
            if (renderer && scene && camera) {
              renderer.render(scene, camera);
            }
          };

          // Update 3D object position
          const update3DObject = (detection) => {
            if (cubes.length === 0 || !camera || !renderer) return;

            // Use position3D from library calculation if available
            const basePosition = detection.position3D || {
              x: 0,
              y: 0,
              z: -detection.depth,
            };

            // Update card position and scale
            const card = cubes[0]; // Single card model

            // Debug: log the position3D values
            console.log("basePosition:", basePosition);
            console.log("detection.depth:", detection.depth);

            // Apply position stabilization for close objects
            const stabilizationDistance = 0.3; // 30cm threshold
            const stabilizationFactor = Math.min(
              detection.depth / stabilizationDistance,
              1.0
            );

            // Smooth X and Y positions for close objects
            const stabilizedX = basePosition.x * stabilizationFactor;
            const stabilizedY = basePosition.y * stabilizationFactor;

            // Set card position with stabilization
            const offsetZ = 0.05;
            const finalX = stabilizedX;
            const finalY = stabilizedY;
            const finalZ = basePosition.z + offsetZ;

            console.log(
              "Stabilization factor:",
              stabilizationFactor.toFixed(3)
            );

            console.log("Final position:", finalX, finalY, finalZ);

            // Update target position for smooth interpolation (but keep detection-based updates)
            targetPosition.x = finalX;
            targetPosition.y = finalY;
            targetPosition.z = finalZ;

            // Apply orientation (pitch and roll) to target rotation for smooth interpolation
            if (detection.orientation) {
              const pitchRad =
                ((detection.orientation.pitch || 0) * Math.PI) / 180;
              const rollRad =
                ((detection.orientation.roll || 0) * Math.PI) / 180;

              // Update target rotations for smooth interpolation
              targetRotation.x = pitchRad;
              targetRotation.z = rollRad;
              targetRotation.y = 0; // Keep Y rotation at 0 for natural look

              console.log(
                "Target rotations - Pitch:",
                detection.orientation.pitch,
                "Roll:",
                detection.orientation.roll
              );
            } else {
              // Reset target rotation if no orientation data
              targetRotation.x = 0;
              targetRotation.y = 0;
              targetRotation.z = 0;
            }

            // Simple fixed scale for all distances
            const scale = 1.0; // Double the scale

            console.log("Distance:", Math.abs(finalZ), "Fixed Scale:", scale);
            card.scale.set(scale, scale, scale);

            // Note: Dynamic lights and final position/rotation are now handled in animate() loop for smoothness

            // Start appearance animation only on first detection
            if (!card.visible) {
              card.visible = true;
              // Only play animation if it hasn't been played before
              if (!cardAnimation.hasPlayedOnce) {
                cardAnimation.isPlaying = true;
                cardAnimation.startTime = Date.now();
                // Set initial animation state
                card.scale.set(cardAnimation.startScale, cardAnimation.startScale, cardAnimation.startScale);
                card.material.opacity = cardAnimation.startOpacity;
                card.material.transparent = true;
                card.position.z = cardAnimation.startY; // Start from bottom
              } else {
                // If animation has played before, set normal state immediately
                card.scale.set(cardAnimation.targetScale, cardAnimation.targetScale, cardAnimation.targetScale);
                card.material.opacity = cardAnimation.targetOpacity;
                card.material.transparent = cardAnimation.targetOpacity < 1.0;
              }
            }
          };

          // Update dynamic lights to follow card rotation
          const updateDynamicLights = (card) => {
            if (dynamicLights.length === 0 || !card.visible) return;

            const cardPos = card.position;
            const cardRot = card.rotation;

            // Light 1: Directional light that maintains angle relative to card
            const light1 = dynamicLights[0];
            if (light1) {
              // Create a vector pointing from card surface
              const lightDirection = new THREE.Vector3(1, 1, 2);
              // Rotate the direction based on card rotation
              lightDirection.applyEuler(cardRot);
              lightDirection.add(cardPos);
              light1.position.copy(lightDirection);
              light1.target.position.copy(cardPos);
              light1.target.updateMatrixWorld();
            }

            // Light 2: Point light that stays close to card
            const light2 = dynamicLights[1];
            if (light2) {
              const lightOffset = new THREE.Vector3(0.02, 0.02, 0.01);
              lightOffset.applyEuler(cardRot);
              light2.position.copy(cardPos).add(lightOffset);
            }

            // Light 3: Accent light from opposite side
            const light3 = dynamicLights[2];
            if (light3) {
              const lightOffset = new THREE.Vector3(-0.015, 0.01, 0.015);
              lightOffset.applyEuler(cardRot);
              light3.position.copy(cardPos).add(lightOffset);
            }
          };

          // Format detection information
          const formatDetectionInfo = (detection) => {
            if (!detection) return null;

            return {
              score: (detection.score * 100).toFixed(1),
              depth: detection.depth?.toFixed(3) || "0.000",
              pitch: detection.orientation?.pitch?.toFixed(1) || "0.0",
              roll: detection.orientation?.roll?.toFixed(1) || "0.0",
              box: detection.boundingBox?.map((v) => Math.round(v)) || [
                0, 0, 0, 0,
              ],
              centerX: detection.center2D?.x
                ? Math.round(detection.center2D.x)
                : 0,
              centerY: detection.center2D?.y
                ? Math.round(detection.center2D.y)
                : 0,
            };
          };

          // Handle detection
          const handleDetection = (detection) => {
            if (!state.isDetecting.value) return;

            if (detection) {
              state.detectionInfo.value = formatDetectionInfo(detection);
              update3DObject(detection);
            } else {
              state.detectionInfo.value = null;
              cubes.forEach((model) => {
                model.visible = false;
              });
            }
          };

          // Initialize detector
          const initDetector = async () => {
            try {
              state.status.value = MESSAGES.CAMERA_INIT;

              const options = {
                ...DETECTOR_OPTIONS,
                onCameraReady: () => {
                  state.status.value = MESSAGES.READY;
                  setTimeout(() => {
                    initThreeJS();
                    animate();
                  }, 500);
                },
                onDetection: handleDetection,
                onCameraNotAllowed: () => {
                  state.error.value = MESSAGES.CAMERA_DENIED;
                },
              };

              detector = await MitsukeLive.createDetector(
                "video",
                "canvas",
                MODEL_PATHS.modelPath,
                MODEL_PATHS.metadataPath,
                options
              );
              state.isDetecting.value = true;
            } catch (err) {
              state.error.value = `Initialization error: ${err.message}`;
              console.error("Detection initialization failed:", err);
            }
          };

          // Start/stop detection
          const toggleDetection = () => {
            if (!detector) return;

            if (state.isDetecting.value) {
              detector.pause();
              state.isDetecting.value = false;
              state.status.value = MESSAGES.PAUSED;
              state.detectionInfo.value = null;
              cubes.forEach((model) => {
                model.visible = false;
              });
            } else {
              detector.resume();
              state.isDetecting.value = true;
              state.status.value = MESSAGES.READY;
            }
          };

          // Lifecycle
          onMounted(initDetector);
          onUnmounted(() => {
            if (animationId) {
              cancelAnimationFrame(animationId);
            }
            if (detector) {
              detector.dispose();
            }
          });

          return {
            ...state,
            toggleDetection,
          };
        },

        template: `
          <div class="app">
            <div class="camera" style="position: relative;">
              <video id="video" class="camera__video" autoplay muted playsinline></video>
              <canvas id="canvas" class="camera__canvas"></canvas>
              <canvas id="ar-canvas" class="camera__canvas" style="position: absolute; top: 0; left: 0; pointer-events: none;"></canvas>
            </div>

            <div class="message">
              <div :class="{ status: !error, error: error }">
                {{ error || status }}
              </div>
            </div>

            <div class="controls">
              <button
                class="controls__btn"
                @click="toggleDetection"
                :title="isDetecting ? 'Stop Detection' : 'Start Detection'"
              >
                <i :class="isDetecting ? 'mdi mdi-pause' : 'mdi mdi-play'"></i>
              </button>
            </div>

            <div class="info" v-if="detectionInfo">
              <div class="info__header">3D/AR Mode - Detection Info</div>
              <div class="info__detection">
                <div class="info__item">
                  <span class="info__label">Score:</span>
                  <span class="info__value monospace">{{ detectionInfo.score }}%</span>
                </div>
                <div class="info__item">
                  <span class="info__label">Depth:</span>
                  <span class="info__value monospace">{{ detectionInfo.depth }}m</span>
                </div>
                <div class="info__item">
                  <span class="info__label">Pitch:</span>
                  <span class="info__value monospace">{{ detectionInfo.pitch }}°</span>
                </div>
                <div class="info__item">
                  <span class="info__label">Roll:</span>
                  <span class="info__value monospace">{{ detectionInfo.roll }}°</span>
                </div>
                <div class="info__item">
                  <span class="info__label">BBox:</span>
                  <span class="info__value monospace">[{{ detectionInfo.box.join(', ') }}]</span>
                </div>
                <div class="info__item">
                  <span class="info__label">Center:</span>
                  <span class="info__value monospace">({{ detectionInfo.centerX }}, {{ detectionInfo.centerY }})</span>
                </div>
              </div>
            </div>
          </div>
        `,
      };

      createApp(DetectionApp).mount("#app");
    </script>
  </body>
</html>
