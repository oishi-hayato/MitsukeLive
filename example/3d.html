<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>MitsukeLive - ARモードデモ</title>
    <link rel="stylesheet" href="style.css" />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/@mdi/font@7.4.47/css/materialdesignicons.min.css"
    />
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
  </head>
  <body>
    <div id="app"></div>

    <script type="module">
      import * as MitsukeLive from "../dist/index.js";

      const { createApp, ref, onMounted, onUnmounted } = Vue;

      // 定数
      const MODEL_PATHS = {
        modelPath: "models/model.json",
        metadataPath: "models/metadata.yaml",
      };

      const DETECTOR_OPTIONS = {
        detection: {
          continuousDetection: true,
          scoreThreshold: 0.7, // 70%以上のスコアのみ検知対象
        },
        threeDEstimation: {
          objectSize: {
            width: 0.02, // 2cm
            height: 0.02, // 2cm
          },
        },
      };

      const MESSAGES = {
        INITIALIZING: "初期化中...",
        CAMERA_INIT: "カメラを初期化中...",
        READY: "物体をスキャンしてください",
        PAUSED: "検出停止中",
        CAMERA_DENIED: "カメラアクセスが拒否されました",
      };

      // 物体検出アプリ
      const DetectionApp = {
        setup() {
          // リアクティブ状態
          const state = {
            status: ref(MESSAGES.INITIALIZING),
            detectionInfo: ref(null),
            error: ref(""),
            isDetecting: ref(false),
          };

          let detector = null;
          let scene = null;
          let camera = null;
          let renderer = null;
          let cubes = []; // 複数のオブジェクトを管理
          let animationId = null;

          // Three.jsシーンの初期化
          const initThreeJS = () => {
            const canvas = document.getElementById("ar-canvas");
            const detectionCanvas = document.getElementById("canvas");

            // レンダラー作成
            renderer = new THREE.WebGLRenderer({
              canvas: canvas,
              alpha: true,
              antialias: true,
            });

            renderer.setSize(detectionCanvas.width, detectionCanvas.height);
            canvas.style.width =
              detectionCanvas.style.width || `${detectionCanvas.width}px`;
            canvas.style.height =
              detectionCanvas.style.height || `${detectionCanvas.height}px`;
            renderer.setPixelRatio(window.devicePixelRatio);

            // シーン作成
            scene = new THREE.Scene();

            // カメラ作成
            camera = new THREE.PerspectiveCamera(
              50,
              detectionCanvas.width / detectionCanvas.height,
              0.1,
              100
            );
            camera.position.z = 0;

            // 複数のキューブを作成（中心のオブジェクト周りに配置）
            const cubeConfigs = [
              {
                color: 0x00ff88,
                offsetX: 0,
                offsetY: 0,
                offsetZ: 0,
                name: "center",
              }, // 中心
              {
                color: 0xff0088,
                offsetX: 0.02,
                offsetY: 0,
                offsetZ: 0,
                name: "right",
              }, // 右
              {
                color: 0x0088ff,
                offsetX: -0.02,
                offsetY: 0,
                offsetZ: 0,
                name: "left",
              }, // 左
              {
                color: 0xffff00,
                offsetX: 0,
                offsetY: 0.02,
                offsetZ: 0,
                name: "top",
              }, // 上
              {
                color: 0xff8800,
                offsetX: 0,
                offsetY: -0.02,
                offsetZ: 0,
                name: "bottom",
              }, // 下
            ];

            cubeConfigs.forEach((config, index) => {
              const geometry = new THREE.BoxGeometry(0.15, 0.15, 0.15);
              const material = new THREE.MeshBasicMaterial({
                color: config.color,
                wireframe: true,
                wireframeLinewidth: 5,
              });
              const cube = new THREE.Mesh(geometry, material);
              cube.visible = false;
              cube.userData = { ...config, index };
              cubes.push(cube);
              scene.add(cube);
            });

            // ライト追加
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
          };

          // Three.jsアニメーションループ
          const animate = () => {
            animationId = requestAnimationFrame(animate);

            // 表示中のキューブを回転
            cubes.forEach((cube) => {
              if (cube.visible) {
                cube.rotation.x += 0.01;
                cube.rotation.y += 0.01;
              }
            });

            if (renderer && scene && camera) {
              renderer.render(scene, camera);
            }
          };

          // 3Dオブジェクトの位置を更新
          const update3DObject = (detection) => {
            if (cubes.length === 0 || !camera || !renderer) return;

            const [x, y, width, height] = detection.boundingBox;
            const detectionCanvas = document.getElementById("canvas");
            const canvasWidth = detectionCanvas.width;
            const canvasHeight = detectionCanvas.height;

            // 検出ボックスの中心座標を計算
            const centerX = x + width / 2;
            const centerY = y + height / 2;

            // Three.jsのワールド座標に変換
            // カメラの視野角とアスペクト比を考慮した座標変換
            const aspect = canvasWidth / canvasHeight;
            const fov = (camera.fov * Math.PI) / 180; // ラジアンに変換
            const depth = detection.depth;

            // 視野角から視野の幅と高さを計算
            const viewHeight = 2 * Math.tan(fov / 2) * depth;
            const viewWidth = viewHeight * aspect;

            // 正規化座標（-1 to 1）に変換
            const normalizedX = (centerX / canvasWidth) * 2 - 1;
            const normalizedY = -((centerY / canvasHeight) * 2 - 1); // Y軸反転

            // ワールド座標に変換
            const worldX = normalizedX * (viewWidth / 2);
            const worldY = normalizedY * (viewHeight / 2);
            const worldZ = -depth; // カメラから離れる方向

            // 各キューブの相対位置を設定
            cubes.forEach((cube, index) => {
              const config = cube.userData;

              // 基本位置にオフセットを追加
              const posX = worldX + config.offsetX;
              const posY = worldY + config.offsetY;
              const posZ = worldZ + config.offsetZ;

              cube.position.set(posX, posY, posZ);

              // スケール計算（深度に基づく - 近いほど大きく）
              const baseScale = index === 0 ? 0.15 : 0.1; // 中心は少し大きく
              const scale = baseScale / Math.max(depth, 0.1); // 近いほど大きく、ゼロ除算防止
              cube.scale.set(scale, scale, scale);

              // 滑らかな表示アニメーション
              if (!cube.visible) {
                cube.visible = true;
                // 小さくスタートして拡大するアニメーション（時間差をつける）
                setTimeout(() => {
                  cube.scale.set(scale * 0.1, scale * 0.1, scale * 0.1);
                  const targetScale = scale;
                  const animateScale = () => {
                    const currentScale = cube.scale.x;
                    if (currentScale < targetScale * 0.95) {
                      const newScale = currentScale * 1.1;
                      cube.scale.set(newScale, newScale, newScale);
                      requestAnimationFrame(animateScale);
                    } else {
                      cube.scale.set(targetScale, targetScale, targetScale);
                    }
                  };
                  animateScale();
                }, index * 100); // 100ms間隔で順次表示
              } else {
                // 既に表示されている場合は単純にスケールを設定
                cube.scale.set(scale, scale, scale);
              }
            });
          };

          // 検出情報をフォーマット
          const formatDetectionInfo = (detection) => ({
            score: (detection.score * 100).toFixed(1),
            depth: detection.depth.toFixed(3),
            pitch: detection.orientation.pitch.toFixed(1),
            roll: detection.orientation.roll.toFixed(1),
            box: detection.boundingBox.map((v) => Math.round(v)),
          });

          // 検出時の処理
          const handleDetection = (detection) => {
            if (!state.isDetecting.value) return;

            if (detection) {
              state.detectionInfo.value = formatDetectionInfo(detection);
              update3DObject(detection);
            } else {
              state.detectionInfo.value = null;
              cubes.forEach((cube) => {
                cube.visible = false;
              });
            }
          };

          // 検出器の初期化
          const initDetector = async () => {
            try {
              state.status.value = MESSAGES.CAMERA_INIT;

              const options = {
                ...DETECTOR_OPTIONS,
                onCameraReady: () => {
                  state.status.value = MESSAGES.READY;
                  setTimeout(() => {
                    initThreeJS();
                    animate();
                  }, 500);
                },
                onDetection: handleDetection,
                onCameraNotAllowed: () => {
                  state.error.value = MESSAGES.CAMERA_DENIED;
                },
              };

              detector = await MitsukeLive.createDetector(
                "video",
                "canvas",
                MODEL_PATHS.modelPath,
                MODEL_PATHS.metadataPath,
                options
              );
              state.isDetecting.value = true;
            } catch (err) {
              state.error.value = `初期化エラー: ${err.message}`;
              console.error("Detection initialization failed:", err);
            }
          };

          // 検出の開始/停止
          const toggleDetection = () => {
            if (!detector) return;

            if (state.isDetecting.value) {
              detector.pause();
              state.isDetecting.value = false;
              state.status.value = MESSAGES.PAUSED;
              state.detectionInfo.value = null;
              cubes.forEach((cube) => {
                cube.visible = false;
              });
            } else {
              detector.resume();
              state.isDetecting.value = true;
              state.status.value = MESSAGES.READY;
            }
          };

          // ライフサイクル
          onMounted(initDetector);
          onUnmounted(() => {
            if (animationId) {
              cancelAnimationFrame(animationId);
            }
            if (detector) {
              detector.dispose();
            }
          });

          return {
            ...state,
            toggleDetection,
          };
        },

        template: `
          <div class="app">
            <div class="camera" style="position: relative;">
              <video id="video" class="camera__video" autoplay muted playsinline></video>
              <canvas id="canvas" class="camera__canvas"></canvas>
              <canvas id="ar-canvas" class="camera__canvas" style="position: absolute; top: 0; left: 0; pointer-events: none;"></canvas>
            </div>

            <div class="message">
              <div :class="{ status: !error, error: error }">
                {{ error || status }}
              </div>
            </div>

            <div class="controls">
              <button
                class="controls__btn"
                @click="toggleDetection"
                :title="isDetecting ? '検出停止' : '検出開始'"
              >
                <i :class="isDetecting ? 'mdi mdi-pause' : 'mdi mdi-play'"></i>
              </button>
            </div>

            <div class="info" v-if="detectionInfo">
              <div class="info__header">ARモード - 検出情報</div>
              <div class="info__detection">
                <div class="info__item">
                  <span class="info__label">信頼度:</span>
                  <span class="info__value monospace">{{ detectionInfo.score }}%</span>
                </div>
                <div class="info__item">
                  <span class="info__label">深度:</span>
                  <span class="info__value monospace">{{ detectionInfo.depth }}m</span>
                </div>
                <div class="info__item">
                  <span class="info__label">上下傾き:</span>
                  <span class="info__value monospace">{{ detectionInfo.pitch }}°</span>
                </div>
                <div class="info__item">
                  <span class="info__label">左右傾き:</span>
                  <span class="info__value monospace">{{ detectionInfo.roll }}°</span>
                </div>
                <div class="info__item">
                  <span class="info__label">位置:</span>
                  <span class="info__value monospace">[{{ detectionInfo.box.join(', ') }}]</span>
                </div>
              </div>
            </div>
          </div>
        `,
      };

      // アプリをマウント
      createApp(DetectionApp).mount("#app");
    </script>
  </body>
</html>
