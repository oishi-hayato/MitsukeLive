<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>MitsukeLive - 3D/AR Mode Demo</title>
    <link rel="stylesheet" href="style.css" />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/@mdi/font@7.4.47/css/materialdesignicons.min.css"
    />
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
  </head>
  <body>
    <div id="app"></div>

    <script type="module">
      import * as MitsukeLive from "mitsuke-live";
      import { createGlossyCard, setupSceneLighting } from "./card-model.js";

      const {
        updateSmoothTargets,
        createSmoothTransformState,
        applySmoothTransform,
      } = MitsukeLive;

      const { createApp, ref, onMounted, onUnmounted } = Vue;

      // Constants
      const MODEL_PATHS = {
        modelPath: "models/model.json",
        metadataPath: "models/metadata.yaml",
      };

      const DETECTOR_OPTIONS = {
        detection: {
          continuousDetection: true,
          inferenceInterval: 100, // Detection frequency: 100ms (10fps)
          scoreThreshold: 0.7, // Only detect objects with 70% or higher confidence
        },
        threeDEstimation: {
          objectSize: {
            width: 0.02, // 2cm
            height: 0.02, // 2cm
          },
        },
      };

      const MESSAGES = {
        INITIALIZING: "Initializing...",
        CAMERA_INIT: "Initializing camera...",
        READY: "Please scan an object",
        PAUSED: "Detection paused",
        CAMERA_DENIED: "Camera access denied",
      };

      const DetectionApp = {
        setup() {
          const state = {
            status: ref(MESSAGES.INITIALIZING),
            detectionInfo: ref(null),
            error: ref(""),
            isDetecting: ref(false),
          };

          // Three.js variables
          let scene = null;
          let camera = null;
          let renderer = null;
          let cards = [];
          let mainGroup = null;
          let animationId = null;

          // Animation and interpolation variables (optimized for performance)
          let lastTime = 0;
          const targetFPS = 30; // Reduce to 20 FPS for better performance
          const frameInterval = 1000 / targetFPS;
          let smoothState = createSmoothTransformState();

          // Detection variables
          let detector = null;
          let lastDetectionTime = 0;
          let hideTimeout = null;

          // Initialize Three.js scene
          const initThreeJS = () => {
            const canvas = document.getElementById("ar-canvas");
            const detectionCanvas = document.getElementById("canvas");

            // Create renderer
            renderer = new THREE.WebGLRenderer({
              canvas: canvas,
              alpha: true,
              antialias: true,
            });

            renderer.setSize(detectionCanvas.width, detectionCanvas.height);
            canvas.style.width =
              detectionCanvas.style.width || `${detectionCanvas.width}px`;
            canvas.style.height =
              detectionCanvas.style.height || `${detectionCanvas.height}px`;
            renderer.setPixelRatio(window.devicePixelRatio);

            // Create scene
            scene = new THREE.Scene();

            // Create camera
            camera = new THREE.PerspectiveCamera(
              50,
              detectionCanvas.width / detectionCanvas.height,
              0.1,
              100
            );
            camera.position.z = 0;

            // Create main group for cards
            mainGroup = new THREE.Group();
            mainGroup.visible = false;
            scene.add(mainGroup);

            // Create card and add to group
            const card = createGlossyCard();
            card.userData = { name: "card", index: 0 };
            cards.push(card);
            mainGroup.add(card);

            // Advanced lighting (heavy)
            setupSceneLighting(scene);
          };

          // Use Three.js built-in linear interpolation
          const lerp = THREE.MathUtils.lerp;

          // Optimized animation loop with smooth interpolation
          const animate = (currentTime) => {
            animationId = requestAnimationFrame(animate);

            if (currentTime - lastTime >= frameInterval) {
              // Apply smooth transform only if main group is visible
              if (mainGroup && mainGroup.visible) {
                cards.forEach((card) => {
                  applySmoothTransform(card, smoothState, 0.15);
                });
              }

              // Only render if main group is visible
              const shouldRender = mainGroup && mainGroup.visible;

              if (renderer && scene && camera && shouldRender) {
                renderer.render(scene, camera);
              }
              lastTime = currentTime;
            }
          };

          // Update card position based on detection
          const updateCardPosition = (detection) => {
            if (!cards[0] || !camera) return;

            const canvas = document.getElementById("canvas");
            const viewport = {
              displayWidth: canvas.width,
              displayHeight: canvas.height,
              detectionWidth: canvas.width,
              detectionHeight: canvas.height,
              fov: camera.fov,
            };

            const halfTanFov = Math.tan((camera.fov * Math.PI) / 180 / 2);

            // Set target position for smooth animation
            updateSmoothTargets(smoothState, detection, viewport, halfTanFov);
          };

          // Format detection information
          const formatDetectionInfo = (detection) => ({
            score: (detection.score * 100).toFixed(1),
            depth: detection.depth.toFixed(3),
            pitch: detection.orientation.pitch.toFixed(1),
            roll: detection.orientation.roll.toFixed(1),
            box: detection.boundingBox.map((v) => Math.round(v)),
          });

          // Show cards when detection found
          const showCards = (detection) => {
            state.detectionInfo.value = formatDetectionInfo(detection);
            updateCardPosition(detection);

            if (mainGroup) {
              mainGroup.visible = true;
              if (!animationId) animate(performance.now());
            }

            if (hideTimeout) {
              clearTimeout(hideTimeout);
              hideTimeout = null;
            }
          };

          // Hide cards after 500ms delay
          const hideCards = () => {
            if (hideTimeout) return;

            hideTimeout = setTimeout(() => {
              state.detectionInfo.value = null;

              if (mainGroup) {
                mainGroup.visible = false;
                if (animationId) {
                  cancelAnimationFrame(animationId);
                  animationId = null;
                }
                if (renderer && scene && camera) {
                  renderer.render(scene, camera);
                }
              }
              hideTimeout = null;
            }, 500);
          };

          // Main detection handler
          const handleDetection = (detection) => {
            if (!state.isDetecting.value) return;

            const isValidDetection =
              detection?.depth !== undefined &&
              detection?.orientation !== undefined;

            if (isValidDetection) {
              showCards(detection);
            } else {
              hideCards();
            }
          };

          // Initialize detector
          const initDetector = async () => {
            try {
              state.status.value = MESSAGES.CAMERA_INIT;

              const options = {
                ...DETECTOR_OPTIONS,
                onCameraReady: () => {
                  state.status.value = MESSAGES.READY;
                  setTimeout(() => {
                    initThreeJS();
                    animate();
                  }, 500);
                },
                onDetection: handleDetection,
                onCameraNotAllowed: () => {
                  state.error.value = MESSAGES.CAMERA_DENIED;
                },
              };

              detector = await MitsukeLive.createDetector(
                "video",
                "canvas",
                MODEL_PATHS.modelPath,
                MODEL_PATHS.metadataPath,
                options
              );
              state.isDetecting.value = true;
            } catch (err) {
              state.error.value = `Initialization error: ${err.message}`;
              console.error("Detection initialization failed:", err);
            }
          };

          // Start/stop detection
          const toggleDetection = () => {
            if (!detector) return;

            if (state.isDetecting.value) {
              detector.pause();
              state.isDetecting.value = false;
              state.status.value = MESSAGES.PAUSED;
              state.detectionInfo.value = null;
              cards.forEach((card) => {
                card.visible = false;
              });
            } else {
              detector.resume();
              state.isDetecting.value = true;
              state.status.value = MESSAGES.READY;
            }
          };

          // Lifecycle
          onMounted(initDetector);
          onUnmounted(() => {
            if (animationId) {
              cancelAnimationFrame(animationId);
            }
            if (detector) {
              detector.dispose();
            }
          });

          return {
            ...state,
            toggleDetection,
          };
        },

        template: `
          <div class="app">
            <div class="camera" style="position: relative;">
              <video id="video" class="camera__video" autoplay muted playsinline></video>
              <canvas id="canvas" class="camera__canvas"></canvas>
              <canvas id="ar-canvas" class="camera__canvas" style="position: absolute; top: 0; left: 0; pointer-events: none;"></canvas>
            </div>

            <div class="message">
              <div :class="{ status: !error, error: error }">
                {{ error || status }}
              </div>
            </div>

            <div class="controls">
              <button
                class="controls__btn"
                @click="toggleDetection"
                :title="isDetecting ? 'Stop Detection' : 'Start Detection'"
              >
                <i :class="isDetecting ? 'mdi mdi-pause' : 'mdi mdi-play'"></i>
              </button>
            </div>

            <div class="info" v-if="detectionInfo">
              <div class="info__header">3D/AR Mode - Detection Info</div>
              <div class="info__detection">
                <div class="info__item">
                  <span class="info__label">Score:</span>
                  <span class="info__value monospace">{{ detectionInfo.score }}%</span>
                </div>
                <div class="info__item">
                  <span class="info__label">Depth:</span>
                  <span class="info__value monospace">{{ detectionInfo.depth }}m</span>
                </div>
                <div class="info__item">
                  <span class="info__label">Pitch:</span>
                  <span class="info__value monospace">{{ detectionInfo.pitch }}°</span>
                </div>
                <div class="info__item">
                  <span class="info__label">Roll:</span>
                  <span class="info__value monospace">{{ detectionInfo.roll }}°</span>
                </div>
                <div class="info__item">
                  <span class="info__label">Position:</span>
                  <span class="info__value monospace">[{{ detectionInfo.box.join(', ') }}]</span>
                </div>
              </div>
            </div>
          </div>
        `,
      };

      createApp(DetectionApp).mount("#app");
    </script>
  </body>
</html>
