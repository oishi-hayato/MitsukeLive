<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>MitsukeLive - ZËª∏Êé®ÂÆöAR „Éá„É¢</title>
    <link rel="stylesheet" href="style.css" />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/@mdi/font@7.4.47/css/materialdesignicons.min.css"
    />
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://unpkg.com/three@0.159.0/build/three.min.js"></script>
  </head>
  <body>
    <div id="app"></div>

    <script type="module">
      import * as MitsukeLive from "../dist/index.js";

      const { createApp, ref, onMounted, onUnmounted } = Vue;

      // MitsukeLive ZËª∏Êé®ÂÆöAR „Ç¢„Éó„É™
      const ARApp = {
        setup() {
          const status = ref("ÂàùÊúüÂåñ‰∏≠...");
          const detectionInfo = ref(null);
          const error = ref("");
          const isDetecting = ref(false);

          let detector = null;
          let scene, camera, renderer;
          let detectedObjects = [];

          // Three.js ÂàùÊúüÂåñ
          const initThreeJS = () => {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(
              75,
              window.innerWidth / window.innerHeight,
              0.1,
              1000
            );
            renderer = new THREE.WebGLRenderer({ alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.domElement.className = "three-canvas";
            document
              .querySelector(".camera-container")
              .appendChild(renderer.domElement);

            // „É©„Ç§„ÉàËøΩÂä†
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);

            animate();
          };

          // „Ç¢„Éã„É°„Éº„Ç∑„Éß„É≥„É´„Éº„Éó
          const animate = () => {
            requestAnimationFrame(animate);

            // Ê§úÂá∫„Åï„Çå„Åü„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÇíÂõûËª¢
            detectedObjects.forEach((obj) => {
              obj.rotation.y += 0.01;
            });

            renderer.render(scene, camera);
          };

          // 3D„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÇíÈÖçÁΩÆ
          const place3DObject = (detection) => {
            // Êó¢Â≠ò„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Çí„ÇØ„É™„Ç¢
            detectedObjects.forEach((obj) => scene.remove(obj));
            detectedObjects = [];

            const [x, y, width, height] = detection.boundingBox;

            // ÁîªÈù¢Â∫ßÊ®ô„Çí3DÂ∫ßÊ®ô„Å´Â§âÊèõÔºà„Éì„Éá„Ç™„Çµ„Ç§„Ç∫„ÇíËÄÉÊÖÆÔºâ
            const video = document.getElementById("video");
            const videoRect = video.getBoundingClientRect();

            // „Éì„Éá„Ç™„Çµ„Ç§„Ç∫„Å´ÂØæ„Åô„ÇãÁõ∏ÂØæ‰ΩçÁΩÆ„ÇíË®àÁÆó
            const relativeX = (x + width / 2) / video.videoWidth;
            const relativeY = (y + height / 2) / video.videoHeight;

            // NDCÂ∫ßÊ®ô„Å´Â§âÊèõÔºà-1„Åã„Çâ1„ÅÆÁØÑÂõ≤Ôºâ
            const screenX = relativeX * 2 - 1;
            const screenY = -(relativeY * 2 - 1);
            const worldZ = detection.depth ? -detection.depth : -2;

            // 3D„Éú„ÉÉ„ÇØ„Çπ„Çí‰ΩúÊàê
            const geometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
            const material = new THREE.MeshLambertMaterial({
              color: 0x00ff88,
              transparent: true,
              opacity: 0.8,
            });
            const cube = new THREE.Mesh(geometry, material);

            // ‰ΩçÁΩÆË®≠ÂÆö
            cube.position.set(
              screenX * Math.abs(worldZ) * 0.5,
              screenY * Math.abs(worldZ) * 0.5,
              worldZ
            );

            // ÂÇæ„Åç„ÇíÈÅ©Áî®
            if (detection.orientation) {
              cube.rotation.x = THREE.MathUtils.degToRad(
                detection.orientation.pitch
              );
              cube.rotation.z = THREE.MathUtils.degToRad(
                detection.orientation.roll
              );
            }

            scene.add(cube);
            detectedObjects.push(cube);
          };

          // Áâ©‰Ωì„Çµ„Ç§„Ç∫ÁôªÈå≤ÔºàÁèæÂú®„ÅÆ„É©„Ç§„Éñ„É©„É™„Åß„ÅØ„Çµ„Éù„Éº„Éà„Åï„Çå„Å¶„ÅÑ„Å™„ÅÑ„Åü„ÇÅ„Ç≥„É°„É≥„Éà„Ç¢„Ç¶„ÉàÔºâ
          const registerObjectSizes = () => {
            // if (MitsukeLive) {
            //   // ÂêçÂà∫„Çµ„Ç§„Ç∫„ÇíÁôªÈå≤ÔºàÊ®ôÊ∫ñÁöÑ„Å™ÂêçÂà∫„Çµ„Ç§„Ç∫Ôºâ
            //   MitsukeLive.setObjectSize("business_card", 0.091, 0.055); // 91mm x 55mm
            //   MitsukeLive.setObjectSize("logo", 0.05, 0.05); // 50mm x 50mm „ÅÆ„É≠„Ç¥
            // }
          };

          // Ê§úÂá∫Âô®ÂàùÊúüÂåñ
          const initDetector = async () => {
            try {
              status.value = "„Ç´„É°„É©„ÇíÂàùÊúüÂåñ‰∏≠...";

              // MitsukeLive„É©„Ç§„Éñ„É©„É™„ÇíÂãïÁöÑ„É≠„Éº„ÉâÔºàÂÆüÈöõ„ÅÆÂÆüË£Ö„Åß„ÅØÈÅ©Âàá„Å´„Ç§„É≥„Éù„Éº„ÉàÔºâ
              if (!MitsukeLive) {
                throw new Error("MitsukeLive „É©„Ç§„Éñ„É©„É™„ÅåË™≠„ÅøËæº„Åæ„Çå„Å¶„ÅÑ„Åæ„Åõ„Çì");
              }

              // Áâ©‰Ωì„Çµ„Ç§„Ç∫„ÇíÁôªÈå≤
              registerObjectSizes();

              const options = {
                modelPath: "../models/model.json",
                metadataPath: "../models/metadata.yaml",
                enableDepthEstimation: true, // ZËª∏Êé®ÂÆö„ÇíÊúâÂäπÂåñ
                enableOrientationEstimation: true, // ÂÇæ„ÅçÊé®ÂÆö„ÇíÊúâÂäπÂåñ
                focalLength: 500, // „Ç´„É°„É©ÁÑ¶ÁÇπË∑ùÈõ¢

                onCameraReady: () => {
                  status.value = "Áâ©‰Ωì„Çí„Çπ„Ç≠„É£„É≥„Åó„Å¶„Åè„Å†„Åï„ÅÑ";
                },

                onDetection: async (detection) => {
                  if (!isDetecting.value) return;

                  detectionInfo.value = {
                    score: (detection.score * 100).toFixed(1),
                    depth: detection.depth ? detection.depth.toFixed(2) : "N/A",
                    pitch: detection.orientation?.pitch?.toFixed(1) || "0",
                    roll: detection.orientation?.roll?.toFixed(1) || "0",
                    box: detection.boundingBox.map((v) => Math.round(v)),
                  };

                  // 3D„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„ÇíÈÖçÁΩÆ
                  place3DObject(detection);

                  // „ÇØ„É©„Ç§„Ç¢„É≥„ÉàÁî®ÁÇπÊªÖ„Ç®„Éï„Çß„ÇØ„Éà„Çí‰ΩøÁî®
                  await MitsukeLive.startClientFlashEffect(
                    document.getElementById("canvas"),
                    detection,
                    {
                      interval: 200, // 200ms„ÅßÁÇπÊªÖ
                      count: 3, // 3ÂõûÁÇπÊªÖ
                      color: "#00ff88", // Á∑ëËâ≤„ÅÆÊû†
                      lineWidth: 3, // Â§™„Åï3px
                    }
                  );

                  // Ê§úÁü•Âæå„ÅØËá™ÂãïÁöÑ„Å´„Éù„Éº„Ç∫„Åï„Çå„Çã„Åü„ÇÅ„ÄÅUI„ÇíÊõ¥Êñ∞
                  isDetecting.value = false;
                  status.value = "Ê§úÂá∫ÂÆå‰∫Ü - ÂÜçÈñã„Åô„Çã„Å´„ÅØ‚ñ∂Ô∏è„Çí„ÇØ„É™„ÉÉ„ÇØ";
                },

                onCameraNotAllowed: () => {
                  error.value = "„Ç´„É°„É©„Ç¢„ÇØ„Çª„Çπ„ÅåÊãíÂê¶„Åï„Çå„Åæ„Åó„Åü";
                },
              };

              detector = new MitsukeLive.DetectionController(options);
              await detector.initialize("video", "canvas");
              isDetecting.value = true;
            } catch (err) {
              error.value = `ÂàùÊúüÂåñ„Ç®„É©„Éº: ${err.message}`;
              console.error("Detection initialization failed:", err);
            }
          };

          // Âà∂Âæ°Ê©üËÉΩ
          const toggleDetection = () => {
            if (detector) {
              if (isDetecting.value) {
                detector.pause();
                isDetecting.value = false;
                status.value = "Ê§úÂá∫ÂÅúÊ≠¢‰∏≠";
                // „Éù„Éº„Ç∫ÊôÇ„Å´3D„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà„Çí„ÇØ„É™„Ç¢
                clearObjects();
              } else {
                detector.resume();
                isDetecting.value = true;
                status.value = "Áâ©‰Ωì„Çí„Çπ„Ç≠„É£„É≥„Åó„Å¶„Åè„Å†„Åï„ÅÑ";
              }
            }
          };

          const clearObjects = () => {
            detectedObjects.forEach((obj) => scene.remove(obj));
            detectedObjects = [];
            detectionInfo.value = null;
          };

          onMounted(() => {
            initThreeJS();
            initDetector();
          });

          onUnmounted(() => {
            if (detector) {
              detector.dispose();
            }
          });

          return {
            status,
            detectionInfo,
            error,
            isDetecting,
            toggleDetection,
          };
        },

        template: `
        <div class="ar-app">
          <div class="camera-container">
            <video id="video" class="camera-video" autoplay muted playsinline></video>
            <canvas id="canvas" class="camera-canvas"></canvas>
          </div>

          <div class="message">
            <div :class="{ status: !error, error: error }">
              {{ error || status }}
            </div>
          </div>

          <div class="controls">
            <button class="control-btn" @click="toggleDetection" :title="isDetecting ? 'Ê§úÂá∫ÂÅúÊ≠¢' : 'Ê§úÂá∫ÈñãÂßã'">
              <i :class="isDetecting ? 'mdi mdi-pause' : 'mdi mdi-play'"></i>
            </button>
          </div>

          <div class="info-panel" v-if="detectionInfo">
            <div><strong>üéØ Ê§úÂá∫ÊÉÖÂ†± (ZËª∏Êé®ÂÆö‰ªò„Åç)</strong></div>
            <div class="detection-info">
              <div>‰ø°È†ºÂ∫¶: {{ detectionInfo.score }}%</div>
              <div>Ê∑±Â∫¶: {{ detectionInfo.depth }}m</div>
              <div>‰∏ä‰∏ãÂÇæ„Åç: {{ detectionInfo.pitch }}¬∞</div>
              <div>Â∑¶Âè≥ÂÇæ„Åç: {{ detectionInfo.roll }}¬∞</div>
              <div>‰ΩçÁΩÆ: [{{ detectionInfo.box.join(', ') }}]</div>
              <div>3DË°®Á§∫: ‚úÖ</div>
            </div>
          </div>
        </div>
      `,
      };

      // „Ç¢„Éó„É™„Çí„Éû„Ç¶„É≥„Éà
      createApp(ARApp).mount("#app");

      // „Éá„É¢Áî®„ÅÆ„É¢„ÉÉ„ÇØ„É©„Ç§„Éñ„É©„É™ÔºàÂÆüÈöõ„ÅÆ‰ΩøÁî®ÊôÇ„ÅØÂâäÈô§Ôºâ
      if (!MitsukeLive) {
        console.warn("„Éá„É¢„É¢„Éº„Éâ: MitsukeLive„É©„Ç§„Éñ„É©„É™„Çí„É¢„ÉÉ„ÇØÂåñ");
        window.MitsukeLive = {
          setObjectSize: (name, w, h) =>
            console.log(`Áâ©‰Ωì„Çµ„Ç§„Ç∫ÁôªÈå≤: ${name} = ${w}x${h}m`),
          DetectionController: class {
            constructor(options) {
              this.options = options;
              setTimeout(() => options.onCameraReady?.(), 1000);

              // „Éá„É¢Áî®„ÅÆÂÆöÊúüÊ§úÂá∫
              setInterval(() => {
                if (this.options.onDetection) {
                  this.options.onDetection?.({
                    boundingBox: [
                      100 + Math.random() * 200,
                      100 + Math.random() * 200,
                      150,
                      100,
                    ],
                    score: 0.8 + Math.random() * 0.2,
                    angle: 0,
                    depth: 1 + Math.random() * 3,
                    orientation: {
                      pitch: (Math.random() - 0.5) * 20,
                      roll: (Math.random() - 0.5) * 30,
                    },
                  });
                }
              }, 3000);
            }
            async initialize() {
              return Promise.resolve();
            }
            pause() {
              console.log("Ê§úÂá∫ÂÅúÊ≠¢");
            }
            resume() {
              console.log("Ê§úÂá∫ÂÜçÈñã");
            }
            dispose() {
              console.log("„É™„ÇΩ„Éº„ÇπËß£Êîæ");
            }
          },
        };
      }
    </script>
  </body>
</html>
